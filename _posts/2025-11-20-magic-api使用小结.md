---
layout:     post
title:      magic-api使用小结
subtitle:
date:       2025-11-20
author:     RC
header-img:
catalog: true
tags:
    - Java
    - API开发
    - 低代码
    - 轻量级框架
---


### 背景

> magic-api是一个基于Java的接口快速开发框架，编写接口将通过magic-api提供的UI界面完成，自动映射为HTTP接口。 无需定义Controller、Service、Dao、Mapper、XML、VO等Java对象即可完成常见的HTTP API接口开发。

公司最近的项目因为快速部署等要求使用了magic-api作为接口开发的框架，本文从基本功能开始，将实际遇到的各种场景需要的代码块和踩坑经验进行展示，仅作记录参考。

### 各种例子

#### 配置连接会话参数

magic-api本身已经支持MySQL、MariaDB、Oracle、DB2、PostgreSQL、SQLServer等支持jdbc规范的数据库，在信创大背景中（xugu、oceanbase），也可以在数据源的URL中直接加上会话参数更好的进行开发工作。

```
jdbc:mysql://xxxx:xxxx/your_schema?sessionVariables=group_concat_max_len=1000000

jdbc:xugu://xxxx:xxxx/your_schema?compatiblemode=MySQL&useSSL=false&current_schema=your_schema
```

> 对应的驱动需要在magic-api驱动包中添加，比如com.xugu.cloudjdbc.Driver

#### MyBatis的动态SQL语法

最常用的if标签，当满足条件时，会拼进SQL语句中，适合大部分入参场景。

```
<if test="reimbursementAmount != null and reimbursementAmount != ''">        
    and total\_amount>=#{reimbursementAmount}                             
</if>
```

多选一的排他逻辑choose，只会执行第一个满足条件的分支，否则执行otherwise（可选），类似switch-case。

```
<choose>
        <when test="phone != null and phone != ''">
            AND phone = #{phone}
        </when>
        <when test="idCard != null and idCard != ''">
            AND id_card = #{idCard}
        </when>
        <otherwise>
            AND status = 1
        </otherwise>
</choose>
```

#### 数据库查询

也是最常用的代码，注意返回的字段都会变成驼峰形式。

```
resList = db['db_name'].select(
"""
    your SQL 
"""
)
```

使用select会返回List，selectOne会返回map。如果需要跨库查询，一般使用schema_name.table_name的表完整名称即可解决。

#### 分页逻辑

也是常用代码，一般的列表展示都会有分页。这里假设入参pageNum=分页编号，pageSize=每一页展示的行数，resList为查询的结果列表。

```
var start_index = pageSize::int * ((pageNum::int) - 1)
var end_index = (pageSize::int) * (pageNum::int)

if (start_index > resList.size()) {
  return {
    total: 0,
    list: []
  }
}

if (end_index > resList.size()) {
  end_index = resList.size()
}

return {
  total: resList.size(),
  list: resList.subList(start_index, end_index)
}
```

注意resList的返回值中最好要有order等字段标识编号顺序，方便前端展示序号。常见的可以使用某个列或者int型主键用row_number()进行排序。

```
ROW_NUMBER() over(ORDER BY a.id ASC) AS `order`
```

#### 树形结构拼接

常见于按照label分类后，每个label展示数量和该label下面的列表，一般是折叠形式展开。

查询列表例子：

```
-- resListD
select 
        row_number() over(order by case when a.chains = '高端能源装备' then 2
        when a.chains = '绿色建材' then 5
        when a.chains = '人工智能' then 3
        when a.chains = '新能源汽车及动力电池' then 4
        when a.chains = '其它' then 0 else 1 end desc, max(a.id) desc) as rk_c,
        a.chains as city,
        row_number() over(order by max(a.id) desc)+7 as rk_p,
        a.project_name as project_name
    from xxx a 
    group by a.chains, a.project_name

-- resList
统计了每个label的数量
```

这里rk_c用于label的排序，rk_p用于每个label下面的子列表的项目名称排序使用（只比较大小）：

```
childList = []
cityMap = {}
    for(item in resListD){
        if(!cityMap[item.get('city')]){
            for (itemR in resList){
                if (itemR.get('city') == item.get('city')){
                    total2 = itemR.get('cnt')
                }
            }
            cityMap[item.get('city')] = {
                "id" : item.get('rkC')::int,
                "label": item.get('city')+'（'+total2+'）',
                "children" : []
            }
        }
        se = {
            "id" : item.get('rkP')::int,
            "label": item.get('projectName')
        }
        cityMap[item.get('city')]['children'].push(se)
    }

    treeList = []
    for (item in cityMap){
        treeList.push(item)
    }
```

cityMap里面存了每个label的Map，有id用于label排序，label拼接名字+数量，以及子列表children。当cityMap没有循环遇到的label时，创建这个label的元素并且计算它的数量。

children则包含了相同label下面的所有project和它们的排序序号，按照label的名字写入对应label的children List中。

循环完成后，将CityMap的所有元素写入新的列表treeList中，用于返回，效果如下：

![1](https://i.postimg.cc/j2F9QDSx/shu-xing-jie-gou.png)

#### 函数

函数主要是将通用逻辑封装后供各个接口使用，需要注意引用时import为@+函数分组名称+/+函数名称，且必须要给一个别名：

```
import "@/group_name/transformUrl" as transformUrl;
```

形参为函数参数点击+号添加，输入参数名和选择类型，参数描述。和接口的入参一样。

#### 调用其他数据源的接口

#### 文件接收和流数据转换

### 参考

