---
layout:     post
title:      magic-api使用小结
subtitle:
date:       2025-11-20
author:     RC
header-img:
catalog: true
tags:
    - Java
    - API开发
    - 低代码
    - 轻量级框架
---


### 背景

> magic-api是一个基于Java的接口快速开发框架，编写接口将通过magic-api提供的UI界面完成，自动映射为HTTP接口。 无需定义Controller、Service、Dao、Mapper、XML、VO等Java对象即可完成常见的HTTP API接口开发。

公司最近的项目因为快速部署等要求使用了magic-api作为接口开发的框架，本文从基本功能开始，将实际遇到的各种场景需要的代码块和踩坑经验进行展示，仅作记录参考。

### 各种例子

#### 配置连接会话参数

magic-api本身已经支持MySQL、MariaDB、Oracle、DB2、PostgreSQL、SQLServer等支持jdbc规范的数据库，在信创大背景中（xugu、oceanbase），也可以在数据源的URL中直接加上会话参数更好的进行开发工作。

```
jdbc:mysql://xxxx:xxxx/your_schema?sessionVariables=group_concat_max_len=1000000

jdbc:xugu://xxxx:xxxx/your_schema?compatiblemode=MySQL&useSSL=false&current_schema=your_schema
```

> 对应的驱动需要在magic-api驱动包中添加，比如com.xugu.cloudjdbc.Driver

#### MyBatis的动态SQL语法

最常用的if标签，当满足条件时，会拼进SQL语句中，适合大部分入参场景。

```
<if test="reimbursementAmount != null and reimbursementAmount != ''">        
    and total\_amount>=#{reimbursementAmount}                             
</if>
```

多选一的排他逻辑choose，只会执行第一个满足条件的分支，否则执行otherwise（可选），类似switch-case。

```
<choose>
        <when test="phone != null and phone != ''">
            AND phone = #{phone}
        </when>
        <when test="idCard != null and idCard != ''">
            AND id_card = #{idCard}
        </when>
        <otherwise>
            AND status = 1
        </otherwise>
</choose>
```

#### 数据库查询

也是最常用的代码，注意返回的字段都会变成驼峰形式。

```
resList = db['db_name'].select(
"""
    your SQL 
"""
)
```

使用select会返回List，selectOne会返回map。如果需要跨库查询，一般使用schema_name.table_name的表完整名称即可解决。

#### 分页逻辑

也是常用代码，一般的列表展示都会有分页。这里假设入参pageNum=分页编号，pageSize=每一页展示的行数，resList为查询的结果列表。

```
var start_index = pageSize::int * ((pageNum::int) - 1)
var end_index = (pageSize::int) * (pageNum::int)

if (start_index > resList.size()) {
  return {
    total: 0,
    list: []
  }
}

if (end_index > resList.size()) {
  end_index = resList.size()
}

return {
  total: resList.size(),
  list: resList.subList(start_index, end_index)
}
```

注意resList的返回值中最好要有order等字段标识编号顺序，方便前端展示序号。常见的可以使用某个列或者int型主键用row_number()进行排序。

```
ROW_NUMBER() over(ORDER BY a.id ASC) AS `order`
```

#### 树形结构拼接

常见于按照label分类后，每个label展示数量和该label下面的列表，一般是折叠形式展开。

查询列表例子：

```
-- resListD
select 
        row_number() over(order by case when a.chains = '高端能源装备' then 2
        when a.chains = '绿色建材' then 5
        when a.chains = '人工智能' then 3
        when a.chains = '新能源汽车及动力电池' then 4
        when a.chains = '其它' then 0 else 1 end desc, max(a.id) desc) as rk_c,
        a.chains as city,
        row_number() over(order by max(a.id) desc)+7 as rk_p,
        a.project_name as project_name
    from xxx a 
    group by a.chains, a.project_name

-- resList
统计了每个label的数量
```

这里rk_c用于label的排序，rk_p用于每个label下面的子列表的项目名称排序使用（只比较大小）：

```
childList = []
cityMap = {}
    for(item in resListD){
        if(!cityMap[item.get('city')]){
            for (itemR in resList){
                if (itemR.get('city') == item.get('city')){
                    total2 = itemR.get('cnt')
                }
            }
            cityMap[item.get('city')] = {
                "id" : item.get('rkC')::int,
                "label": item.get('city')+'（'+total2+'）',
                "children" : []
            }
        }
        se = {
            "id" : item.get('rkP')::int,
            "label": item.get('projectName')
        }
        cityMap[item.get('city')]['children'].push(se)
    }

    treeList = []
    for (item in cityMap){
        treeList.push(item)
    }
```

cityMap里面存了每个label的Map，有id用于label排序，label拼接名字+数量，以及子列表children。当cityMap没有循环遇到的label时，创建这个label的元素并且计算它的数量。

children则包含了相同label下面的所有project和它们的排序序号，按照label的名字写入对应label的children List中。

循环完成后，将CityMap的所有元素写入新的列表treeList中，用于返回，效果如下：

![1](https://i.postimg.cc/j2F9QDSx/shu-xing-jie-gou.png)

#### 函数

函数主要是将通用逻辑封装后供各个接口使用，需要注意引用时import为@+函数分组名称+/+函数名称，且必须要给一个别名：

```
import "@/group_name/transformUrl" as transformUrl;
```

形参为函数参数点击+号添加，输入参数名和选择类型，参数描述。和接口的入参一样。

#### 调用其他数据源的接口

这一部分主要是签名生成，按照对方接口要求即可，发起请求用最普通的框架内置的HTTP请求工具类。

下面是一个请求oss文件预编译地址的例子：

```
import org.apache.commons.codec.digest.DigestUtils
import http

// fileAddr = "/attachment/20251128/XXX/file_name.jpg"

// 配置接口鉴权信息
access_key = "XXX"  
secret = "XXX"   

// 1. 生成毫秒级时间戳
def timestamp = System.currentTimeMillis()

// 2. 生成UUID格式的requestId
def request_id = UUID.randomUUID().toString()

// 3. 生成sign：拼接后MD5加密并转大写
def sign_str = access_key+secret+timestamp+request_id
def sign = DigestUtils.md5Hex(sign_str).toUpperCase()

// 4. 构造请求体
def requestBody = { 
    "data": {
        "access_key": access_key,
        "sign": sign,
        "timestamp": timestamp,
        "request_id": request_id,
        "filePaths": [fileAddr]
    }
}

// 5. 发送POST请求（Magic API内置HttpUtils）
def url = "http://ip:port/api/api_name"
def headers = {"Content-Type": "application/json"}

var result=http.connect(url).body(requestBody).contentType('application/json').post().getBody();

var respObj = result['data'][fileAddr]

return respObj
```

#### 文件接收和流数据转换

文件一般有两种情况，一是预览，比如图片等，这类如果不转base64格式，就需要在magic-api中请求后以流的形式返回给前端，有几点需要注意：

1、返回的Response Headers中的Content-Type必须和文件类型一致，不能用保底的通过返回APPLICATION_OCTET_STREAM_VALUE，可以通过传入的文件完整路径的文件名后缀枚举完成。

2、为防止http请求的400错误，需要对中文的文件名进行编码（utf-8）。

3、前端接收时直接转为blob文件， payload.request这个方法需要能够支持responseType的入参。

4、内网走图片预览，公网走word、pdf浏览器下载，所以要保证magic-api所在的服务器能够访问oss获取到文件。

完整例子参考：

```
import java.net.URL
import java.net.URLConnection
import java.io.InputStream
import java.io.OutputStream
import org.springframework.http.HttpHeaders
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.core.io.InputStreamResource
import java.net.URLEncoder
import java.nio.charset.StandardCharsets

def publicFileUrl = fileUrl
if (fileUrl != '' and fileUrl != null){
    try {
        // 1、对文件名进行编码，防止中文400
        // 原始URL（Groovy支持def声明变量，也可显式用String）
        def originalUrl = fileUrl
        // 分割URL：提取前缀和文件名
        def lastSlashIndex = originalUrl.lastIndexOf('/')
        def urlPrefix = originalUrl.substring(0, lastSlashIndex + 1) // 前缀（含最后一个/）
        def fileName = originalUrl.substring(lastSlashIndex + 1)    // 文件名部分

        // 使用Java URLEncoder编码（指定UTF-8，避免乱码）
        def encodedFileName = URLEncoder.encode(fileName, StandardCharsets.UTF_8.name())
        // 将URLEncoder生成的"+"替换为URL标准的"%20"（若文件名含空格）
        encodedFileName = encodedFileName.replace("+", "%20")

        // 拼接新URL
        def newUrl = urlPrefix + encodedFileName
        publicFileUrl = newUrl
        
        // 2. 创建连接对象，截取文件名
        def conn = new URL(publicFileUrl).openConnection()
        conn.connect()
        def fileName = publicFileUrl.substring(publicFileUrl.lastIndexOf("/") + 1)

        // 3. 自定义扩展名到Content-Type的映射表（覆盖常见类型，可扩展）
        def mimeTypes = {
            "jpg": "image/jpeg",
            "jpeg": "image/jpeg",
            "png": "image/png",
            "gif": "image/gif",
            "bmp": "image/bmp",
            "webp": "image/webp",
            "pdf": "application/pdf",
            "doc": "application/msword",
            "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "xls": "application/vnd.ms-excel",
            "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "ppt": "application/vnd.ms-powerpoint",
            "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
            "txt": "text/plain",
            "html": "text/html",
            "css": "text/css",
            "js": "application/javascript",
            "json": "application/json",
            "zip": "application/zip",
            "rar": "application/x-rar-compressed",
            "mp4": "video/mp4",
            "mp3": "audio/mpeg"
            // 可根据业务需求扩展更多类型
        }

        def fileExt = fileName.contains(".") ? fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase() : ""

        // 4. 嵌套三元运算符
        def connContentType = conn.getContentType()
        def fileContentType = (mimeTypes[fileExt] != null) 
            ? mimeTypes[fileExt] 
            : (URLConnection.guessContentTypeFromName(fileName) != null)
                ? URLConnection.guessContentTypeFromName(fileName)
                : (connContentType != null)
                    ? connContentType
                    : MediaType.APPLICATION_OCTET_STREAM_VALUE
            
        def headers = new HttpHeaders()
        headers.setContentType(MediaType.parseMediaType(fileContentType))
        headers.set("Content-Disposition", "attachment; filename=" + fileName)
        def contentLength = conn.getContentLengthLong()
        if (contentLength > 0) {
            headers.setContentLength(contentLength)
        }
        // 5. 获取网络连接的字节输入流，并将其包装为Spring标准的Resource资源对象
        def inputStream = conn.getInputStream()
        def resource = new InputStreamResource(inputStream)
        // 6. magic-api自动处理HTTP响应输出
        return ResponseEntity.ok().headers(headers).body(resource)

    } catch{
        // 异常处理
        return ResponseEntity.status(500)
                .body("文件处理失败：${e.getMessage()}")
    }
}else{
    return null
}
```

### 小结

magic-api 基于 Spring Boot+Groovy 构建，核心优势为接口脚本化开发，无需编译部署，轻量化易集成；深度复用 Spring 生态，支持多数据源、二进制数据处理等场景；可快速迭代接口开发，降低微服务场景下的接口交付成本，兼具灵活性与标准化，显著提升开发效率。其语法和各种场景的例子需要我们继续深入学习。

### 参考

[magic-api官方例子](https://magic-api.ssssssss.org.cn/magic/web/index.html)

[magic-api对接其他数据源csdn](https://blog.csdn.net/weixin_43491173/article/details/132580144)

