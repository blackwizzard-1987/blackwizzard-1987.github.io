---
layout:     post
title:      知识图谱绘制和ETL过程整理(下)
subtitle:
date:       2024-06-03
author:     RC
header-img:
catalog: true
tags:
    - 知识图谱
    - 图数据库
    - NebulaGraph
    - 大数据
    - ETL
---

### 关于NebulaGraph

出于查询性能、存储和可扩展性考虑，我们最后选择了NebulaGraph替代Neo4j作为产品正式上线的底层图数据库服务。

NebulaGraph是国产的开源图数据库，基于Apache 2.0 条款下开发，性能非常卓越，并且支持openCypher查询语言，具体可以看下他们的[DB手册](https://docs.nebula-graph.com.cn/3.8.0/1.introduction/1.what-is-nebula-graph/)。

但是在使用之初，还是有一定的学习成本，并且我们需要**从Neo4j把数据迁移到NebulaGraph并且适配新的查询**，过程中还是遇到了一些问题。这篇文章通过实际本体建模和构建图谱的ETL过程中的经历和克服的困难进行了简单的总结，并展示了阶段性成果。

> NebulaGraph本身支持**分布式集群部署**，通过console的add host添加副本机器，并且可以通过Docker Compose安装，非常的方便，当然，我们也可以在虚拟机上**单机安装**进行测试

> NebulaGraph拥有**图形化界面的NebulaGraph Studio**，可以完成/查看本体建模的shcema，创建space、tag、edge、index等，完成少量数据的import工作，**易用性很强**

> 目前NebulaGraph可以免费使用约20天的企业版，只需要在阿里云上面提交申请，自动部署生成实例，参考[从云开始（免费试用）](https://docs.nebula-graph.com.cn/3.8.0/2.quick-start/2.start-free-trial-on-cloud/)，听说有炫酷的3D渲染图形效果

> 本文讨论的NebulaGraph版本均为3.8.0

#### 图空间(space)

Neo4j社区版一大诟病就是一个Neo4j数据库实例只能拥有一个类似于关系型数据库的database。而社区版的NebulaGraph则可以直接**通过图空间（space）将不同领域的数据进行隔离**，相当于可以同时存在互不影响的多个database供用户使用，每个图空间都可以指定不同的存储副本数、权限、分片等。这也是基于分布式存储的优势。

图空间还提供了整个space下面的**各个基本模型的定义**，以及整个图谱的**点、边统计，按tag计数**，还有类似于**本体构建**的view schema和对应的schema drafting：

![1](https://i.postimg.cc/SsVvkkbk/1.png)

![2](https://i.postimg.cc/Jh5T5MnZ/2.png)

#### ETL的不同

Neo4j中为了增量导入数据，我们的ETL都是通过load csv形式实现的，这和NebulaGraph有一定的区别。

在NebulaGraph中，常用的数据导入方式分为五种：

- **图形化操作**：通过NebulaGraph Studio的import功能，管理数据源和创建导入任务实现ETL，本质是csv文件的导入，需要通过csv的列值映射（mapping）到VID、prop、Rank上，对于**小型数据集**来说比较效率。创建的任务也可以重复执行，并且可以自定义名字，修改内容，上传的csv文件可以覆盖进行数据、结构等的更新

- **nGQL语句**：通过nGQL语法的Insert语句，在NebulaGraph Console的**白屏命令**中直接执行，虽然更加直接，但需要实现对Insert语句按照语法进行值的拼接

- **NebulaGraph Importer**：是一款NebulaGraph的**CSV文件单机导入**工具，可以读取并批量导入多种数据源的 CSV文件数据，还支持批量更新和删除操作。其本质也是csv文件的导入，但是每个任务都需要手动配置importer的xml配置文件

- **NebulaGraph Exchange**：是一款 Apache Spark应用，用于在分布式环境中将集群中的数据批量迁移到 NebulaGraph 中，能支持多种不同格式的批式数据和流式数据的迁移。一般是Neo4j、Hive、MySQL等多种源分布式导入，需要有Spark集群，适用于**大量数据**，十亿条数据以上的场景

- **编写程序**：通过**C++/GO/Java/Python SDK编写程序**导入数据，需要有一定编程和调优能力，简单版的也可以拼接数据为nGQL语句然后execute

上面的五种方式由于目前第一版产品的数据量限制还没有使用过NebulaGraph Exchange。

其中和Neo4j最相似又有巨大不同的就是涉及csv导入的方式。

在Neo4j中，csv的导入可以和图数据库中的查询操作一起进行，在固定csv的某一行后，我们就可以用它的值去match图数据库中的点了，这在某种程度上可以**极大的减少csv文件的数量**，你甚至可以在同一个csv中同时创建tag和导入点的tag的属性的值，并同时导入多个类型的实体和它们的关系

但在NebulaGraph Exchange的csv导入中，**列的mapping限制了对csv行的操作**，使得整个导入必须严格按照VID列、tag的属性值列、edge的source VID列、destination VID列、edge的属性值列、edge的Rank列**建立和csv文件的列的映射关系进行导入**，这样会带来两个问题：

- csv文件的数据**无法在导入时和图数据库的数据进行关联查询**、筛选等

- **很难把N个实体和它们的关系融合进一个csv中**（比如人的属性和人的家庭关系、社会关系等）

对于拥有很多不同edge的图谱来说，为了提高效率，就不得不去维护一个专门的tag csv和它们的关系csv，其中**包含了源目标的VID和边的属性值、Rank值**，同样也会导致csv文件变得很多，难以维护。

> 前期demo构建后，项目后期基本都通过导入关系型数据库表的方式，然后**程序化处理原来的csv文件的数据**了，考虑到今后的扩展和数据量成倍增加，这是不得不做的一件事

当然，通过NebulaGraph Studio的import功能对csv进行导入确实是比较易用的，图形化的操作加上任务的一定编排功能使得整个ETL变得机械化和模板化，但同时也提高了**csv的维护成本**。

在项目的实际投入使用中，不定时的增量更新图谱的数据意味着必须使用程序通过关系型数据库的**模板化的数据**，将点和边拼接成insert语句直接在NebulaGraph中执行。

#### 点(vertex)

官方对点vertex的定义是用来保存实体对象，他有两个特点：

- 点是用点标识符（VID）标识的。VID在同一图空间中唯一。VID 是一个 int64，或者 fixed_string(N)

- 点可以有0到多个Tag

关于和这两点我们可以在后面详细解释和讨论。

点其实就是本体建模中的实体。

这里需要注意的是点的**VID值会在渲染出来的图形中直接显示**，并且在开源版本的NebulaGraph中无法更改，不同于Neo4j可以更改点（一般是个圆形）显示出来的值为这个点的任意属性。

##### VID

VID（Vertex ID）的官方定义是图空间中，一个点由点的ID唯一标识，这个ID就是VID。

VID的特点如下：

- VID的类型在定义图空间的时候定义，只能为FIXED_STRING(<N>)或INT64，设置后不可更改

- VID的生成方式必须由用户自行指定，**系统不提供自增ID或者UUID**

- VID在同一个图空间中必须**唯一**

- **VID相同的点，会被认为是同一个点**

- VID以LSM-tree方式索引并缓存在内存中，因此直接访问VID的性能最高

- VID必须在插入点时设置，且一旦设置无法修改

- NebulaGraph的查询语句（MATCH、GO、LOOKUP）都是以start vid开始的，通过显式指定VID或者属性的索引来定位，如GO FROM "player100" OVER中的player100，MATCH (v:player {name:"Tony Parker"})中的player.name

由于VID必须在插入点时定义，因此一般**选取业务上唯一的属性（字段）作为VID，或者选取组合起来后有唯一性的属性（字段）生成VID**。

> 注意，因为边Edge没有VID，因此边的名字都是边定义的时候指定的，它的缺点是前后点相同、同名的边的属性只会保留最后一次写入的值，如果要显示出相同点之间的同名的多条边，需要加入Rank，此时，不同Rank的同名边的属性值可以不同。

##### 标签(Tag)

官方对标签Tag的定义是**由一组事先预定义的属性构成**。

这里有一个很重要的点，就是**相同点的不同tag会进行合并**，可以理解为这个点拥有多个标签和它们的属性，比如下图：

![3](https://i.postimg.cc/15zkGkSy/3.png)

红色部分每个"|"分隔出来的都一个标签tag，每个tag又有自己的属性，由于它们都在一个点上，因此这个点拥有不同的tag。

因此，如果将tag单纯的理解为key:value格式的列表，或者说类比于关系型数据库中的单张表，都不太准确，或者说**只在每个点上面只有一个tag的时候是正确的**。

我们可以通过insert语句再直观的看一下：

```html
INSERT VERTEX `个人标签_家庭生活` (`独生子女`) VALUES '张大山_510583196303010001':('否');
```

这里的个人标签_家庭生活是tag的名字，独生子女是它的属性，张大山_510583196303010001是点的VID（后文会讲，就是点、实体的唯一标识），否是独生子女这个属性的值。

那么，当另一个标签，无论它的属性和属性值是什么，只要values后面的**点的VID值相同，这些标签就会同时出现在一个点、实体上**。

也许NebulaGraph的设计思路就是**创建N个标签，然后实体们各自拥有M个标签，它们整体构成了实体和属性**。但这也意味着整个图谱中定义的标签必须是可以描述大部分实体的。

有多个标签的实体有时候并不是好事，因为这会让**实体的VID要求更高**，如果VID不能区分各个实体，那么多个标签的属性的值就会出现覆盖的情况，即**相同VID的点的相同tag的属性值会互相覆盖，只保留最后一次写入的值**。

另一种思路是通过相同VID上面的多个tag（来源于不同的图谱）来搜集一些**包含业务含义的数据**，比如：

```html
MATCH (a)  
WHERE size(tags(a)) >= 2 AND ANY(item IN tags(a) WHERE item == '企业标签')  
RETURN id(a), tags(a)
```

这个nGQL试图找出任意tag包含了企业标签并且点上面拥有2个及以上tag的点的VID，如果政策标签恰好也有一些标签名字和企业标签的名字（VID）一样，它们就会被找到，作为两者共有的标签。

通过VID和tag的特点我们可以看出，**VID相当于一个实体的唯一标号，Tag相当于实体所拥有的身份、类型**，Tag本身的属性则描述了拥有Tag的身份、类型的人、物体的特征。

#### 边(Edge)

官方对边(Edge)的定义是**边用来连接点，表示两个点之间的关系或行为**。

边的特点如下：

- 两点之间可以有多条边

- 边是有方向的，不存在无向边

- 四元组 <起点 VID、Edge type、边排序值 (rank)、终点 VID> 用于唯一标识一条边。边没有EID

- 一条边有且仅有一个 Edge type，即边的名字

- 一条边有且仅有一个 Rank，类型为 int64，默认值为 0

通过以上特点可以看出，如果已有Edge type、起点、终点、Rank都相同的边，新的Insert Edge操作会覆盖原边的属性。由于边没有EID，因此**边的Edge type在命名时要认真思考唯一性和重复性**，只有Edge type、起点、终点相同的边可以用Rank进行区分。

一般的Insert Edge语句如下：

```html
INSERT EDGE `包含申报材料`(`事项标签类型`, `事项要素`) VALUES "【成都市】2024年成都市体育小巨人企业奖励"->"标准材料-企业知识产权证"@0:('申报材料', '资质证明');      
```

可以看出与Inset vertex的最大区别是加入了起点和终点以及边的方向、边的Rank值。

实际上，在实际的图谱构建过程中，**实体和关系的数量总是你增我减的，我们倾向于将实体都作为唯一的存在，重复的部分放在关系中展示**。这样的好处是当我们根据条件过滤时，边上面的查询不需要建立和重建索引，而实体tag上的按属性查询要求属性上有索引。

##### Rank

**Rank可以用来区分Edge type、起始点、目的点都相同的边**。

Rank的特点：

- 一条边有且仅有一个Rank

- Rank的类型为int64，默认值为0，为0时，相同Edge的属性值会互相覆盖

- openCypher中没有Rank的概念

Rank是边的一个比较特殊的值，是边的排序值，原因是边**没有EID去区分所谓的相同tag的不同边**，即Nebula Graph中的相同Edge Type的属性不做边的区分，而是互相覆盖。可以认为Rank是边的另一种限制了类型只能为int64的EID。

在实际使用中，边的Rank值主要用于**头尾点固定但又有多条相同定义的边需要展示**的情况，比如：个人和任职单位、个人和毕业院校、事项要素和标准字段等场景。一个人在一家单位可能在不同时间段都呆过，一个人在同一个学校可能在不同时间段都学习过，事项要素相同、标准字段相同的事项会有多个。对于前面的情况，可以选择**工作开始时间**、**毕业时间**转为Unix时间作为单向流动的Rank进行区分，后面的事项通过唯一标识进行区分：

![4](https://i.postimg.cc/xT6n3s1m/4.png)

Rank的存在保证了Nebula Graph可以完整的显示所有节点相同的多个同名关系，不论是本身的渲染还是数据提取后渲染都可以有数据支撑。

#### 索引(Index)

Nebula Graph中的索引分为原生索引和全文索引。

全文索引是基于Elasticsearch来实现的，用于对字符串属性进行前缀搜索、通配符搜索、正则表达式搜索和模糊搜索，在项目中并没有用到。

原生索引可以建在点的Tag或Tag的某个属性，边的Edge type或Edge type的某个属性上，可以通过指定的 Tag、Edge type、属性查询数据。同常见的索引结构一样，索引本身不存储数据，而是存储数据的位置。

需要注意的是，如果tag或者edge已经有值了再去创建索引，**创建之后必须rebuild索引才能使索引生效**。Nebula Graph也不提供唯一索引来对插入值进行约束。

#### nGQL和Cypher

按照官方的说法，nGQL是NebulaGraph使用的的声明式图查询语言，它是一个进行中的项目，会持续发布新特性和优化，总的来说，**nGQL语言 = 原生nGQL语句 + openCypher兼容语句**

nGQL主要兼容了Cypher的部分的DQL语句(match, optional match, with), 具体区别如下：

![5](https://i.postimg.cc/02Yy9MFc/5.png)

可以看到nGQL除了一些运算符的不同，它是**不支持merge操作**的，这是一个很大的区别。在Neo4j中我们可以不关心属性完全相同的重复点，因为数据库会帮我们自动合并它们，但是NebulaGraph就不支持了。但实际上因为NebulaGraph强制要求写入点时需要指定VID，这个意义上没有merge操作也是不冲突的。

官方GitHub的features目录提供了超过2500条nGQL示例，包括上下文和背景描述，非常的详细，值得学习。

> 对于Go From的写法按照官方文档的说法是比match更加效率，但我们暂时没有使用这种语法

### 工作方法

在熟悉Nebula Graph的各种数据模型和ETL操作之后，我们根据知识图谱从关系型数据库的各个表、按照规则梳理出的csv文件这两种比较特殊的数据源构建的整个过程总结了一些经验作为流程化的知识图谱构建步骤：

- 梳理知识图谱数据模板：根据业务和领域知识梳理出对应**知识图谱的数据模板，这些模板主要由领域本身的标签或者产品设计原型形成**。

- 选取样例数据填充知识图谱数据模板：根据梳理好的知识图谱数据模板，选取领域内典型的数据进行填充，这里面涉及到数据的标准化处理、各个数据源的融合，甚至需要先建立好某些标签体系等大量人工工作。

- 本体建模：根据模板和模板数据对知识图谱进行本体建模，基本上在前两个步骤中已经涉及了一部分实体和关系的选择，剩下的部分主要根据**产品原型设计和设计经验决定（基本是倾向于实体唯一，关系重复）**，因为同时需要考虑实体、VID、边和它们的属性，所以后续在实际load的过程中需要进行一定调整。

- ETL构建图谱：将知识图谱的模板数据按照本体建模的实体、关系和属性导入到图数据库中，这块基本都按照**程序解析后拼接成Insert语句处理**了。要求前面的模板数据需要落入关系型数据库的表中方便操作。

- 配套查询：这部分工作主要是根据产品原型设计来对功能点需要的数据设计图数据库的查询语句。也是和前后端开发联调的地方，根据数据情况有一定的调整。**对于一些复杂的数据产出，需要一组nGQL才能满足**。

- 数据验证：最后，根据**查询输出的结果对比数据源的结果**，检查是否有差异，遗漏或者增多。也需要关图数据库中孤立的点和一些ETL过程中产生的脏数据，对它们进行处理。

### 部分效果展示

多事项关联查询：

![6](https://i.postimg.cc/7YhSJgvY/6.png)

主要展示了不同事项之间的**相同表单字段、相同材料**、部门关系等。

> 此图为NebulaGraph本身的渲染效果，前后端处理后会整齐排列，按照每一层和叶子节点个数填充方块大小。


多事项依赖关系：

![7](https://i.postimg.cc/LXm19PBS/7.png)


主要展示了事项办理结果材料和另外的事项所需材料之间的依赖关系，前置事项就是产生标准材料的事项，后续事项就是需要标准材料的事项，《出生医学证明》首次签发办理后可以拿到出生医学证明，出生医学证明可以用来办理户口登记（包括注销、恢复、变更），而户口登记（包括注销、恢复、变更）办理后可以拿到居民户口簿，居民户口簿可以用来办理企业职工基本养老保险关系转移接续申请，以此类推。**主要用于联办、一件事等场景**。

个人图谱：

![8](https://i.postimg.cc/bw8DHbWt/8.png)

主要展示了个人的家庭信息、工作经理、学习经历、社保户籍、证件情况等信息。

> 为示例数据

### 总结和展望

知识图谱的构建绝对不是一个一蹴而就的事情，虽然我们没有按照文本提取的标准步骤取建立知识图谱，但在过程中也充分感受了图数据库相比于传统数据图带来的优势和它们的特点。知识图谱最重要的地方也是**前期对业务、知识领域的理解和梳理工作，形成知识**，图数据库实际上是对这些知识的图形化展示和探索。

总之，知识图谱的构建是一个复杂而精细的过程，它不仅仅涉及技术层面的实现，**更重要的是对业务逻辑、知识体系的深入理解和梳理**，需要综合考虑业务、技术、数据等多个方面的因素。通过深入的业务理解和知识领域分析，结合图数据库的优势和特点，才可以构建出高效、直观、可扩展的知识图谱。

### 参考

[NebulaGraph Database手册](https://docs.nebula-graph.com.cn/3.8.0/1.introduction/1.what-is-nebula-graph/)



