---
layout:     post
title:      知识图谱绘制和ETL过程整理(下)
subtitle:
date:       2024-06-03
author:     RC
header-img:
catalog: true
tags:
    - 知识图谱
    - 图数据库
    - NebulaGraph
    - 大数据
    - ETL
---

### 关于NebulaGraph

出于查询性能、存储和可扩展性考虑，我们最后选择了NebulaGraph替代Neo4j作为产品正式上线的底层图数据库服务。

NebulaGraph是国产的开源图数据库，基于Apache 2.0 条款下开发，性能非常卓越，并且支持openCypher查询语言，具体可以看下他们的[DB手册](https://docs.nebula-graph.com.cn/3.8.0/1.introduction/1.what-is-nebula-graph/)。

但是在使用之初，还是有一定的学习成本，并且我们需要**从Neo4j把数据迁移到NebulaGraph并且适配新的查询**，过程中还是遇到了一些问题。这篇文章通过实际本体建模和构建图谱的ETL过程中的经历和克服的困难进行了简单的总结，并展示了阶段性成果。

> NebulaGraph本身支持**分布式集群部署**，通过console的add host添加副本机器，并且可以通过Docker Compose安装，非常的方便，当然，我们也可以在虚拟机上**单机安装**进行测试

> NebulaGraph拥有**图形化界面的NebulaGraph Studio**，可以完成/查看本体建模的shcema，创建space、tag、edge、index等，完成少量数据的import工作，**易用性很强**

> 目前NebulaGraph可以免费使用约20天的企业版，只需要在阿里云上面提交申请，自动部署生成实例，参考[从云开始（免费试用）](https://docs.nebula-graph.com.cn/3.8.0/2.quick-start/2.start-free-trial-on-cloud/)，听说有炫酷的3D渲染图形效果

#### 图空间(space)

Neo4j社区版一大诟病就是一个Neo4j数据库实例只能拥有一个类似于关系型数据库的database。而社区版的NebulaGraph则可以直接**通过图空间（space）将不同领域的数据进行隔离**，相当于可以同时存在互不影响的多个database供用户使用，每个图空间都可以指定不同的存储副本数、权限、分片等。这也是基于分布式存储的优势。

图空间还提供了整个space下面的**各个基本模型的定义**，以及整个图谱的**点、边统计，按tag计数**，还有类似于**本体构建**的view schema和对应的schema drafting：

![1](https://i.postimg.cc/SsVvkkbk/1.png)

![2](https://i.postimg.cc/Jh5T5MnZ/2.png)

#### ETL的不同

Neo4j中为了增量导入数据，我们的ETL都是通过load csv形式实现的，这和NebulaGraph有一定的区别。

在NebulaGraph中，常用的数据导入方式分为五种：

- **图形化操作**：通过NebulaGraph Studio的import功能，管理数据源和创建导入任务实现ETL，本质是csv文件的导入，需要通过csv的列值映射（mapping）到VID、prop、Rank上，对于**小型数据集**来说比较效率。创建的任务也可以重复执行，并且可以自定义名字，修改内容，上传的csv文件可以覆盖进行数据、结构等的更新

- **nGQL语句**：通过nGQL语法的Insert语句，在NebulaGraph Console的**白屏命令**中直接执行，虽然更加直接，但需要实现对Insert语句按照语法进行值的拼接

- **NebulaGraph Importer**：是一款NebulaGraph的**CSV文件单机导入**工具，可以读取并批量导入多种数据源的 CSV文件数据，还支持批量更新和删除操作。其本质也是csv文件的导入，但是每个任务都需要手动配置importer的xml配置文件

- **NebulaGraph Exchange**：是一款 Apache Spark应用，用于在分布式环境中将集群中的数据批量迁移到 NebulaGraph 中，能支持多种不同格式的批式数据和流式数据的迁移。一般是Neo4j、Hive、MySQL等多种源分布式导入，需要有Spark集群，适用于**大量数据**，十亿条数据以上的场景

- **编写程序**：通过**C++/GO/Java/Python SDK编写程序**导入数据，需要有一定编程和调优能力，简单版的也可以拼接数据为nGQL语句然后execute

上面的五种方式由于目前第一版产品的数据量限制还没有使用过NebulaGraph Exchange。

其中和Neo4j最相似又有巨大不同的就是涉及csv导入的方式。

在Neo4j中，csv的导入可以和图数据库中的查询操作一起进行，在固定csv的某一行后，我们就可以用它的值去match图数据库中的点了，这在某种程度上可以**极大的减少csv文件的数量**，你甚至可以在同一个csv中同时创建tag和导入点的tag的属性的值，并同时导入多个类型的实体和它们的关系

但在NebulaGraph Exchange的csv导入中，**列的mapping限制了对csv行的操作**，使得整个导入必须严格按照VID列、tag的属性值列、edge的source VID列、destination VID列、edge的属性值列、edge的Rank列**建立和csv文件的列的映射关系进行导入**，这样会带来两个问题：

- csv文件的数据**无法在导入时和图数据库的数据进行关联查询**、筛选等

- **很难把N个实体和它们的关系融合进一个csv中**（比如人的属性和人的家庭关系、社会关系等）

对于拥有很多不同edge的图谱来说，为了提高效率，就不得不去维护一个专门的tag csv和它们的关系csv，其中**包含了源目标的VID和边的属性值、Rank值**，同样也会导致csv文件变得很多，难以维护。

> 前期demo构建后，项目后期基本都通过导入关系型数据库表的方式，然后**程序化处理原来的csv文件的数据**了，考虑到今后的扩展和数据量成倍增加，这是不得不做的一件事

当然，通过NebulaGraph Studio的import功能对csv进行导入确实是比较易用的，图形化的操作加上任务的一定编排功能使得整个ETL变得机械化和模板化，但同时也提高了**csv的维护成本**。

在项目的实际投入使用中，不定时的增量更新图谱的数据意味着必须使用程序通过关系型数据库的**模板化的数据**，将点和边拼接成insert语句直接在NebulaGraph中执行。

#### 点(vertex)

官方对点vertex的定义是用来保存实体对象，他有两个特点：

- 点是用点标识符（VID）标识的。VID在同一图空间中唯一。VID 是一个 int64，或者 fixed_string(N)

- 点可以有0到多个Tag

关于和这两点我们可以在后面详细解释和讨论。

点其实就是本体建模中的实体。

这里需要注意的是点的**VID值会在渲染出来的图形中直接显示**，并且在开源版本的NebulaGraph中无法更改，不同于Neo4j可以更改点（一般是个圆形）显示出来的值为这个点的任意属性。

##### VID

VID（Vertex ID）的官方定义是图空间中，一个点由点的ID唯一标识，这个ID就是VID。

VID的特点如下：

- VID的类型在定义图空间的时候定义，只能为FIXED_STRING(<N>)或INT64，设置后不可更改

- VID的生成方式必须由用户自行指定，**系统不提供自增ID或者UUID**

- VID在同一个图空间中必须**唯一**

- **VID相同的点，会被认为是同一个点**

- VID以LSM-tree方式索引并缓存在内存中，因此直接访问VID的性能最高

- VID必须在插入点时设置，且一旦设置无法修改

- NebulaGraph的查询语句（MATCH、GO、LOOKUP）都是以start vid开始的，通过显式指定VID或者属性的索引来定位，如GO FROM "player100" OVER中的player100，MATCH (v:player {name:"Tony Parker"})中的player.name

由于VID必须在插入点时定义，因此一般**选取业务上唯一的属性（字段）作为VID，或者选取组合起来后有唯一性的属性（字段）生成VID**。

> 注意，因为边Edge没有VID，因此边的名字都是边定义的时候指定的，它的缺点是前后点相同、同名的边的属性只会保留最后一次写入的值，如果要显示出相同点之间的同名的多条边，需要加入Rank，此时，不同Rank的同名边的属性值可以不同。

##### 标签(Tag)

官方对标签Tag的定义是**由一组事先预定义的属性构成**。

这里有一个很重要的点，就是**相同点的不同tag会进行合并**，可以理解为这个点拥有多个标签和它们的属性，比如下图：

![3](https://i.postimg.cc/15zkGkSy/3.png)

红色部分每个|分隔出来的都一个标签tag，每个tag又有自己的属性，由于它们都在一个点上，因此这个点拥有不同的tag。

因此，如果将tag单纯的理解为key:value格式的列表，或者说类比于关系型数据库中的单张表，都不太准确，或者说**只在每个点上面只有一个tag的时候是正确的**。

我们可以通过insert语句再直观的看一下：

```html
INSERT VERTEX `个人标签_家庭生活` (`独生子女`) VALUES '张大山_510583196303010001':('否');
```

这里的个人标签_家庭生活是tag的名字，独生子女是它的属性，张大山_510583196303010001是点的VID（后文会讲，就是点、实体的唯一标识），否是独生子女这个属性的值。

那么，当另一个标签，无论它的属性和属性值是什么，只要values后面的**点的VID值相同，这些标签就会同时出现在一个点、实体上**。

也许NebulaGraph的设计思路就是**创建N个标签，然后实体们各自拥有M个标签，它们整体构成了实体和属性**。但这也意味着整个图谱中定义的标签必须是可以描述大部分实体的。

有多个标签的实体有时候并不是好事，因为这会让**实体的VID要求更高**，如果VID不能区分各个实体，那么多个标签的属性的值就会出现覆盖的情况，即**相同VID的点的相同tag的属性值会互相覆盖，只保留最后一次写入的值**。

另一种思路是通过相同VID上面的多个tag（来源于不同的图谱）来搜集一些**包含业务含义的数据**，比如：

```html
MATCH (a)  
WHERE size(tags(a)) >= 2 AND ANY(item IN tags(a) WHERE item == '企业标签')  
RETURN id(a), tags(a)
```

这个nGQL试图找出任意tag包含了企业标签并且点上面拥有2个及以上tag的点的VID，如果政策标签恰好也有一些标签名字和企业标签的名字（VID）一样，它们就会被找到，作为两者共有的标签。

通过VID和tag的特点我们可以看出，**VID相当于一个实体的唯一标号，Tag相当于实体所拥有的身份、类型**，Tag本身的属性则描述了拥有Tag的身份、类型的人、物体的特征。

#### 边(Edge)




##### Rank

**Rank可以用来区分Edge type、起始点、目的点都相同的边**。

Rank的特点：

- 一条边有且仅有一个Rank

- Rank的类型为int64，默认值为0，为0时，相同Edge的属性值会互相覆盖

- openCypher中没有Rank的概念

Rank是边的一个比较特殊的值，是边的排序值，原因是边**没有EID去区分所谓的相同tag的不同边**，即Nebula Graph中的相同Edge Type的属性不做边的区分，而是互相覆盖。可以认为Rank是边的另一种限制了类型只能为int64的EID。

在实际使用中，边的Rank值主要用于**头尾点固定但又有多条相同定义的边需要展示**的情况，比如：个人和任职单位、个人和毕业院校、事项要素和标准字段等场景。一个人在一家单位可能在不同时间段都呆过，一个人在同一个学校可能在不同时间段都学习过，事项要素相同、标准字段相同的事项会有多个。对于前面的情况，可以选择**工作开始时间**、**毕业时间**转为Unix时间作为单向流动的Rank进行区分，后面的事项通过唯一标识进行区分：

![4](https://i.postimg.cc/xT6n3s1m/4.png)

Rank的存在保证了Nebula Graph可以完整的显示所有节点相同的多个同名关系，不论是本身的渲染还是数据提取后渲染都可以有数据支撑。

#### 索引(Index)


#### nGQL和Cypher

#### 其他优缺点

### 总结和展望

### 参考

